import {FeedImageType, FeedState} from "./FeedContext";

export const FEED_ACTIONS = {
    SET_FEED_HISTORY: 'SET_FEED_HISTORY',
    SET_CURRENT_IMAGE: 'SET_CURRENT_IMAGE',
    SET_HISTORY_AND_CURRENT_IMAGE: 'SET_HISTORY_AND_CURRENT_IMAGE',
    SET_DRAG_STATE: 'SET_DRAG_STATE',
    SET_USER_REACTION: 'SET_USER_REACTION',
    CLEAR_USER_REACTION: 'CLEAR_USER_REACTION',
    ADD_PROMPT_TO_HISTORY: 'ADD_USER_PROMPT_TO_HISTORY',
    SET_FEED_TYPE: 'SET_FEED_TYPE',
}

const background = {
    "Up": "i like it\u00A0\u00A0\u00A0\u00A0\u00A0".repeat(300),
    "Left": "it inspires me\u00A0\u00A0\u00A0\u00A0\u00A0".repeat(300),
    "Right": "it surprises me\u00A0\u00A0\u00A0\u00A0\u00A0".repeat(300),
    "Down": "it terrifies me\u00A0\u00A0\u00A0\u00A0\u00A0".repeat(300),
}

export const reactionMap = {
    "Up": "ðŸ‘",
    "Left": "ðŸ¤¯",
    "Right": "ðŸ˜®",
    "Down": "ðŸ˜±",
}

export const feedReducer = (state: FeedState, action: any) => {
    switch (action.type) {
        case FEED_ACTIONS.SET_FEED_HISTORY:
            if (!action.payload.feedHistory) return state;
            return {...state, feedHistory: action.payload.feedHistory};
        case FEED_ACTIONS.SET_CURRENT_IMAGE:
            // case when image is in the drag state too long
            if (state.dragState.isDragging) return state;

            const newImage = action.payload.currentImage as FeedImageType;
            if (!newImage) return state;

            let feedHistory = state.feedHistory ? state.feedHistory : [];

            // add to history only if the new image was generated by the server
            if (state.currentImage && state.currentImage.url !== newImage.url) {
                // remove the oldest image if we have more than 10
                if (feedHistory.length > 20) {
                    feedHistory.shift();
                }
                // add the current image to the history
                feedHistory = [...feedHistory, state.currentImage];
            }
            return {...state, currentImage: newImage, feedHistory: feedHistory};


        case FEED_ACTIONS.SET_HISTORY_AND_CURRENT_IMAGE:
            return {...state, feedHistory: action.payload.feedHistory, currentImage: action.payload.currentImage};
        case FEED_ACTIONS.SET_DRAG_STATE:
            if (action.payload.isDragging) {
                const text = background[action.payload.direction as keyof typeof background];

                return {
                    ...state,
                    dragState: {
                        direction: action.payload.direction,
                        magnitude: action.payload.magnitude,
                        backgroundText: text,
                        isDragging: action.payload.isDragging
                    },
                    tutorial: false, // disable tutorial after first dragging event
                };
            } else {
                let userReaction = undefined;
                if (action.payload.magnitude > 0.5) {
                    userReaction = {
                        reaction: reactionMap[action.payload.direction as keyof typeof reactionMap],
                        imageId: state.currentImage ? state.currentImage.id : -1
                    }
                }

                // end of drag
                return {
                    ...state,
                    dragState: {direction: '', magnitude: 0, backgroundText: '', isDragging: false},
                    userReaction: userReaction
                };
            }
        case FEED_ACTIONS.SET_USER_REACTION:
            return {...state, userReaction: action.payload.userReaction};
        case FEED_ACTIONS.CLEAR_USER_REACTION:
            return {...state, userReaction: undefined};
        case FEED_ACTIONS.ADD_PROMPT_TO_HISTORY:
            const newPrompt = action.payload.userPrompt;
            if (!newPrompt) return state;
            if (newPrompt === state.userPrompt) return state;

            let feedHistoryOld = state.feedHistory ? state.feedHistory : [];

            return {...state, feedHistory: [...feedHistoryOld, newPrompt], userPrompt: newPrompt};

        case FEED_ACTIONS.SET_FEED_TYPE:
            return {...state, feedType: action.payload.feedType as FeedState["feedType"]};

        default:
            return state;
    }
}